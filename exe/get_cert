#!/bin/sh ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib')

require 'openssl'

require 'letsencrypt_webfaction/args_parser'

options = LetsencryptWebfaction::ArgsParser.new(ARGV)

unless options.valid?
  puts options.errors.values.join("\n")
  exit
end

# START PROCEDURAL CODE.

# We're going to need a private key.
private_key = OpenSSL::PKey::RSA.new(options.key_size)

# Initialize the client
require 'acme/client'
client = Acme::Client.new(private_key: private_key, endpoint: options.endpoint)

# If the private key is not known to the server, we need to register it for the first time.
registration = client.register(contact: "mailto:#{options.contact}")

# You'll may need to agree to the term (that's up the to the server to require it or not but boulder does by default)
registration.agree_terms

# Let's try to optain a certificate

options.domains.each do |domain|
  puts "Validating #{domain}"

  # We need to prove that we control the domain using one of the challenges method.
  authorization = client.authorize(domain: domain)

  # For now the only challenge method supprted by the client is http-01.
  challenge = authorization.http01

  # Save the file. We'll create a public directory to serve it from, and we'll creating the challenge directory.
  FileUtils.mkdir_p(File.join(options.public, File.dirname(challenge.filename)))

  # Then writing the file
  File.write(File.join(options.public, challenge.filename), challenge.file_content)

  # Once you are ready to serve the confirmation request you can proceed.
  raise 'Failed requesting verification' unless challenge.request_verification # => true

  i = 0
  until challenge.verify_status == 'valid' || i == 10
    # Wait a bit for the server to make the request, or really just blink, it should be fast.
    sleep(1)

    puts challenge.verify_status # => 'pending'
    i += 1
  end

  unless challenge.verify_status == 'valid'
    raise "Failed to verify status in 10 seconds. Current status: #{challenge.verify_status}"
  end
end

# We're going to need a certificate signing request. If not explicitly
# specified, the first name listed becomes the common name.
csr = Acme::Client::CertificateRequest.new(names: options.domains)

# We can now request a certificate, you can pass anything that returns
# a valid DER encoded CSR when calling to_der on it, for example a
# OpenSSL::X509::Request too.
certificate = client.new_certificate(csr) # => #<Acme::Client::Certificate ....>

# Save the certificate and key
File.write('privkey.pem', certificate.request.private_key.to_pem)
File.write('cert.pem', certificate.to_pem)
File.write('chain.pem', certificate.chain_to_pem)
File.write('fullchain.pem', certificate.fullchain_to_pem)
