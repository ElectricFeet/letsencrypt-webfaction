#!/usr/bin/env ruby

# TODO: Remove this line. http://guides.rubygems.org/patterns/
$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib')

require 'openssl'
require 'acme/client'

require 'letsencrypt_webfaction/args_parser'
require 'letsencrypt_webfaction/domain_validator'
require 'letsencrypt_webfaction/certificate_writer'
require 'letsencrypt_webfaction/instructions'

options = LetsencryptWebfaction::ArgsParser.new(ARGV)

unless options.valid?
  puts options.errors.values.join("\n")
  exit
end

# START PROCEDURAL CODE.

# We're going to need a private key.
private_key = OpenSSL::PKey::RSA.new(options.key_size)

# Initialize the client
client = Acme::Client.new(private_key: private_key, endpoint: options.endpoint)

# If the private key is not known to the server, we need to register it for the first time.
registration = client.register(contact: "mailto:#{options.contact}")

# You'll may need to agree to the term (that's up the to the server to require it or not but boulder does by default)
registration.agree_terms

# Let's try to optain a certificate

# Validate the domain.
validator = LetsencryptWebfaction::DomainValidator.new options.domains, client, options.public
validator.validate!

# We're going to need a certificate signing request. If not explicitly
# specified, the first name listed becomes the common name.
csr = Acme::Client::CertificateRequest.new(names: options.domains)

# We can now request a certificate, you can pass anything that returns
# a valid DER encoded CSR when calling to_der on it, for example a
# OpenSSL::X509::Request too.
certificate = client.new_certificate(csr) # => #<Acme::Client::Certificate ....>

writer = LetsencryptWebfaction::CertificateWriter.new(options.output_dir, options.domains.first, certificate)
writer.write!

# Dump help text.
instructions = LetsencryptWebfaction::Instructions.new writer.output_dir, options.domains
puts instructions.message
